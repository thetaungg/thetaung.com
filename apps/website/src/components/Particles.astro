---
export interface Props {
    class?: string;
}

const { class: className = '' } = Astro.props;
---

<div class={`particles-container ${className}`} data-particles>
    <canvas id="particles-canvas"></canvas>
</div>

<script>
    interface Particle {
        x: number;
        y: number;
        vx: number;
        vy: number;
        size: number;
        opacity: number;
        color: string;
        angle: number;
        rotationSpeed: number;
        elongation: number;
    }

    class ParticleSystem {
        private canvas: HTMLCanvasElement;
        private ctx: CanvasRenderingContext2D;
        private particles: Particle[] = [];
        private mouseX: number = -1000;
        private mouseY: number = -1000;
        private animationId: number = 0;
        private resizeObserver: ResizeObserver;
        private container: HTMLElement;

        constructor(canvas: HTMLCanvasElement) {
            this.canvas = canvas;
            this.ctx = canvas.getContext('2d')!;
            this.container = canvas.closest('[data-particles]') as HTMLElement;

            this.resizeObserver = new ResizeObserver(() => this.resize());
            this.resizeObserver.observe(this.container);

            this.resize();
            this.init();
            this.bindEvents();
            this.animate();
        }

        private resize() {
            const dpr = window.devicePixelRatio || 1;
            const rect = this.container.getBoundingClientRect();

            this.canvas.width = rect.width * dpr;
            this.canvas.height = rect.height * dpr;
            this.canvas.style.width = `${rect.width}px`;
            this.canvas.style.height = `${rect.height}px`;
            this.ctx.scale(dpr, dpr);

            this.init();
        }

        private init() {
            const rect = this.container.getBoundingClientRect();
            // Higher density to match Antigravity
            const particleCount = Math.floor((rect.width * rect.height) / 4000);
            this.particles = [];

            const colors = [
                'rgba(59, 130, 246, opacity)', // blue-500
                'rgba(37, 99, 235, opacity)', // blue-600
                'rgba(148, 163, 184, opacity)', // slate-400
                'rgba(203, 213, 225, opacity)', // slate-300
            ];

            for (let i = 0; i < particleCount; i++) {
                this.particles.push(this.createParticle(colors, rect));
            }
        }

        private createParticle(colors: string[], rect: DOMRect): Particle {
            return {
                x: Math.random() * rect.width,
                y: Math.random() * rect.height,
                vx: (Math.random() - 0.5) * 0.15,
                vy: (Math.random() - 0.5) * 0.15 - 0.1,
                // Much smaller particles - 0.5 to 1.5px instead of 1 to 4px
                size: Math.random() * 1 + 0.5,
                opacity: Math.random() * 0.4 + 0.1,
                color: colors[Math.floor(Math.random() * colors.length)],
                angle: Math.random() * Math.PI * 2,
                rotationSpeed: (Math.random() - 0.5) * 0.01,
                elongation: Math.random() * 1.5 + 1,
            };
        }

        private bindEvents() {
            // Track mouse on the entire document so it works over content
            document.addEventListener('mousemove', e => {
                const rect = this.container.getBoundingClientRect();
                // Check if mouse is within the hero section bounds
                if (
                    e.clientX >= rect.left &&
                    e.clientX <= rect.right &&
                    e.clientY >= rect.top &&
                    e.clientY <= rect.bottom
                ) {
                    this.mouseX = e.clientX - rect.left;
                    this.mouseY = e.clientY - rect.top;
                } else {
                    this.mouseX = -1000;
                    this.mouseY = -1000;
                }
            });
        }

        private animate = () => {
            this.animationId = requestAnimationFrame(this.animate);
            this.update();
            this.draw();
        };

        private update() {
            const rect = this.container.getBoundingClientRect();

            this.particles.forEach(p => {
                // Mouse interaction - particles gently pushed away
                const dx = p.x - this.mouseX;
                const dy = p.y - this.mouseY;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const maxDist = 120;

                if (dist < maxDist && dist > 0) {
                    const force = (1 - dist / maxDist) * 0.3;
                    p.vx += (dx / dist) * force;
                    p.vy += (dy / dist) * force;
                }

                // Apply velocity with damping
                p.x += p.vx;
                p.y += p.vy;
                p.vx *= 0.98;
                p.vy *= 0.98;

                // Add gentle drift
                p.vx += (Math.random() - 0.5) * 0.01;
                p.vy += (Math.random() - 0.5) * 0.01 - 0.005;

                // Rotate
                p.angle += p.rotationSpeed;

                // Wrap around edges
                if (p.x < -10) p.x = rect.width + 10;
                if (p.x > rect.width + 10) p.x = -10;
                if (p.y < -10) p.y = rect.height + 10;
                if (p.y > rect.height + 10) p.y = -10;
            });
        }

        private draw() {
            const rect = this.container.getBoundingClientRect();
            this.ctx.clearRect(0, 0, rect.width, rect.height);

            this.particles.forEach(p => {
                this.ctx.save();
                this.ctx.translate(p.x, p.y);
                this.ctx.rotate(p.angle);

                // Draw small elongated particle
                this.ctx.beginPath();
                this.ctx.ellipse(0, 0, p.size * p.elongation, p.size, 0, 0, Math.PI * 2);
                this.ctx.fillStyle = p.color.replace('opacity', String(p.opacity));
                this.ctx.fill();

                this.ctx.restore();
            });
        }

        public destroy() {
            cancelAnimationFrame(this.animationId);
            this.resizeObserver.disconnect();
        }
    }

    // Initialize when DOM is ready
    const initParticles = () => {
        const canvas = document.getElementById('particles-canvas') as HTMLCanvasElement;
        if (canvas && !canvas.dataset.initialized) {
            canvas.dataset.initialized = 'true';
            new ParticleSystem(canvas);
        }
    };

    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initParticles);
    } else {
        initParticles();
    }
</script>

<style>
    .particles-container {
        position: absolute;
        inset: 0;
        overflow: hidden;
        pointer-events: none;
    }

    #particles-canvas {
        position: absolute;
        inset: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
    }
</style>
